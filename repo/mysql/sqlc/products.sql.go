// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: products.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createProduct = `-- name: CreateProduct :execresult
INSERT INTO products (
    name,
    description,
    price,
    order_by,
    is_recommendation,
    total_quantity,
    sold_quantity,
    status
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ? 
)
`

type CreateProductParams struct {
	Name             string         `json:"name"`
	Description      string         `json:"description"`
	Price            uint32         `json:"price"`
	OrderBy          int32          `json:"order_by"`
	IsRecommendation bool           `json:"is_recommendation"`
	TotalQuantity    uint32         `json:"total_quantity"`
	SoldQuantity     uint32         `json:"sold_quantity"`
	Status           ProductsStatus `json:"status"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (sql.Result, error) {
	return q.exec(ctx, q.createProductStmt, createProduct,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.OrderBy,
		arg.IsRecommendation,
		arg.TotalQuantity,
		arg.SoldQuantity,
		arg.Status,
	)
}

const deleteProductById = `-- name: DeleteProductById :exec
DELETE FROM
    products
WHERE
    id = ?
`

func (q *Queries) DeleteProductById(ctx context.Context, id uint32) error {
	_, err := q.exec(ctx, q.deleteProductByIdStmt, deleteProductById, id)
	return err
}

const getProductById = `-- name: GetProductById :one
SELECT
    id, created_at, updated_at, name, description, price, order_by, is_recommendation, total_quantity, sold_quantity, status
FROM
    products
WHERE
    1 = 1
    AND id = ?
`

func (q *Queries) GetProductById(ctx context.Context, id uint32) (Product, error) {
	row := q.queryRow(ctx, q.getProductByIdStmt, getProductById, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.OrderBy,
		&i.IsRecommendation,
		&i.TotalQuantity,
		&i.SoldQuantity,
		&i.Status,
	)
	return i, err
}

const listTheRecommendedProducts = `-- name: ListTheRecommendedProducts :many
SELECT
    id,
    name,
    price,
    order_by
FROM
    products
WHERE
    1 = 1
    AND is_recommendation = true
    AND total_quantity >= sold_quantity
    AND status = 'on'
ORDER BY
    order_by DESC,
	created_at DESC
LIMIT ?
OFFSET ?
`

type ListTheRecommendedProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListTheRecommendedProductsRow struct {
	ID      uint32 `json:"id"`
	Name    string `json:"name"`
	Price   uint32 `json:"price"`
	OrderBy int32  `json:"order_by"`
}

func (q *Queries) ListTheRecommendedProducts(ctx context.Context, arg ListTheRecommendedProductsParams) ([]ListTheRecommendedProductsRow, error) {
	rows, err := q.query(ctx, q.listTheRecommendedProductsStmt, listTheRecommendedProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTheRecommendedProductsRow{}
	for rows.Next() {
		var i ListTheRecommendedProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.OrderBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
